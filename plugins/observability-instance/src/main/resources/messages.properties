
"DB.enable_thread_pool.suggestExplain         = Open thread pool function on said.
"DB.log_duration.suggestExplain               = With this option is set to off, log_min_duration_statement differs log_min_duration_statement record query text.
"DB.log_min_duration_statement.suggestExplain = Set to 250, all run time not shorter than 250 ms SQL statements can be recorded.
"DB.log_statement.suggestExplain              = None said not recorded statements.DDL said record all data definition statements, such as CREATE, ALTER, and DROP statement.

"OS.vm.overcommit_memory.suggestExplain = Vm. Overcommit_memory file specifies the kernel for memory allocation strategy, its value is 0, 1, 2

0 = (default) said the kernel will check whether there is enough memory available supply process; If there is enough memory available, memory applications allow; Otherwise, the memory for failure, and the error is returned to the application process. 0 is heuristic overcommitting handle, will try to reduce the use of the swap, the root can be allocated slightly more memory than the average user

1 = the kernel allows allocation of all physical memory, however, the current state of the memory, allowing more than CommitLimit, until run out of memory. On the database server is set to 1, is not recommended to try to avoid using the swap.

2 = said not allowed more than CommitLimit values"

DB.bgwriter_delay.paramDetail             = Set the write the back-end process "dirty" the time interval between the Shared buffer
DB.bgwriter_delay.suggestExplain          = In the larger data write pressure can try to reduce the value in the scene in order to reduce the pressure of the checkpoint
DB.bgwriter_delay.unit                    = ms
DB.bgwriter_thread_num.paramDetail        = Set the backend process
DB.bgwriter_thread_num.unit               = The number of
DB.enable_thread_pool.paramDetail         = The control function of whether to use a thread pool
DB.enable_thread_pool.unit                = Boolean value
DB.log_duration.paramDetail               = Control each completed record of SQL statement execution time. Extended query protocols are used for the client, will record the syntax analysis, binding, and perform the time spent on each step
DB.log_duration.unit                      = Boolean value
DB.log_error_verbosity.paramDetail        = Control server log write the detailed degree of each record
DB.log_error_verbosity.suggestExplain     = Terse represents output does not include the DETAIL, HINT, records of the QUERY and the CONTEXT error message.Verbose output including SQLSTATE error code, source code file name, the function name and the number of rows in the wrong.Default on behalf of output including the DETAIL, HINT, records of the QUERY and the CONTEXT error messages, not including SQLSTATE error code, source code file name, the function name and the number of rows in the wrong
DB.log_error_verbosity.unit               = Enumeration type
DB.log_min_duration_statement.paramDetail = When the duration of a statement is greater than or equal to the specified number of milliseconds, log_min_duration_statement parameter is used to control the record the duration of each complete statement
DB.log_min_duration_statement.unit        = ms
DB.log_min_error_statement.paramDetail    = Control in the SQL server error log.
DB.log_min_error_statement.suggestExplain = \u6709\u6548\u503C\u6709\u8C03\u8BD5\u3001debug5 debug4, debug3, debug2, debug1,\u4FE1\u606F,\u65E5\u5FD7,\u6CE8\u610F,\u8B66\u544A\u3001\u9519\u8BEF,\u81F4\u547D\u7684,\u6050\u614C\u3002
DB.log_min_error_statement.unit           = Enumeration type
DB.log_min_messages.paramDetail           = The message level control to the server log file. Each level contains the information in the row behind it all levels. The lower level, the less the server running log message
DB.log_min_messages.suggestExplain        = \u6709\u6548\u503C\u6709\u8C03\u8BD5\u3001debug5 debug4, debug3, debug2, debug1,\u4FE1\u606F,\u65E5\u5FD7,\u6CE8\u610F,\u8B66\u544A\u3001\u9519\u8BEF,\u81F4\u547D\u7684,\u6050\u614C\u3002
DB.log_min_messages.unit                  = Enumeration type
DB.log_statement.paramDetail              = Control record SQL statements. On extending the query protocols used by the client, record received news events and the value of the binding parameters
DB.log_statement.unit                     = Enumeration type
DB.max_io_capacity.paramDetail            = Set the back-end process batch brush pages per second IO ceiling, need according to specific business scenarios and disk I/o capability set machine
DB.max_io_capacity.unit                   = KB
DB.max_process_memory.paramDetail         = Set up a database node largest physical memory available
DB.max_process_memory.suggestExplain      = Database node on the numerical need according to the system of physical memory and single node deployment master database nodes is decided. Computation formula is as follows: (physical memory size - vm. Min_free_kbytes)  * 0.7 / (1 master node number). The coefficient of the purpose is to guarantee the reliability of the system as much as possible, not caused by database memory expansion node OOM. The formula mentioned in the vm min_free_kbytes, its meaning is reserved operating system memory used by the kernel, is often used as a communication transceiver in the operating system kernel memory allocation, at least for 5 \uFFFD. Namely, max_process_memory = physical memory * 0.665 / (1) master node number
DB.max_process_memory.unit                = Boolean value
DB.pagewriter_sleep.paramDetail           = On the set for incremental checkpoint, pagewrite thread every brush pagewriter_sleep time of a batch of dirty pages footwall. When the proportion of dirty pages occupy shared_buffers reaches dirty_page_percent_max, each batch of pages at a set number of max_io_capacity page to calculate the value of the brush, the rest is less in proportion each batch page number
DB.pagewriter_sleep.unit                  = ms
DB.thread_pool_attr.paramDetail           = Detailed attribute is used to control the function of the thread pool, this parameter can only take effect after enable_thread_pool open.
DB.thread_pool_attr.unit                  = character
DB.track_stmt_retention_time.paramDetail  = Combination of parameters, control the quantity/slow SQL record retention time. Read the parameters for 60 seconds period, and perform the cleaning records of more than retention time, only the sysadmin user can access
DB.track_stmt_retention_time.unit         = character
DB.track_stmt_stat_level.paramDetail      = Control statement execution trace level, the parameters in the first part is not OFF, will record all the SQL, the first part is OFF, the second part is a OFF cases, only records the slow SQL
DB.track_stmt_stat_level.unit             = character
DB.work_mem.paramDetail                   = Job execution judgment may use memory in the footwall operator is influenced by inventory
DB.work_mem.suggestExplain                = Parameter is usually a balance, that is, to ensure the concurrent throughput, and to ensure the Performance of the single query operation, so the need according to the actual implementation (a combination of the Explain output Performance) tuning
DB.work_mem.unit                          = Boolean value

OS.MTU.paramDetail                              = The maximum transmission unit node network card. OS the default value is 1500, adjusted to 8192 can improve the performance of SCTP protocol data transceiver
OS.MTU.unit                                     = byte
OS.kernel.sem.paramDetail                       = The kernel semaphore parameters set size
OS.kernel.sem.unit                              = byte
OS.kernel.shmall.paramDetail                    = The kernel of the available amount of Shared memory
OS.kernel.shmall.unit                           = byte
OS.kernel.shmmax.paramDetail                    = A maximum of the kernel parameters define a single Shared memory segment
OS.kernel.shmmax.unit                           = byte
OS.net.core.netdev_max_backlog.paramDetail      = In the rate of each network interface receives packets faster than the rate of kernel processing these packages, to allow the maximum number of packets sent to queue
OS.net.core.netdev_max_backlog.unit             = The number of
OS.net.core.rmem_default.paramDetail            = The default value of the receiver of the socket buffer size
OS.net.core.rmem_default.suggestExplain         = The default receive window size
OS.net.core.rmem_default.unit                   = byte
OS.net.core.rmem_max.paramDetail                = The maximum number of sockets receiver buffer size
OS.net.core.rmem_max.suggestExplain             = Most TCP data receiving buffer
OS.net.core.rmem_max.unit                       = byte
OS.net.core.somaxconn.paramDetail               = Defines the system of each port's largest listening to the queue length
OS.net.core.somaxconn.suggestExplain            = Used to limit the number of listening (LISTEN) biggest packet queue, more than the number of links will lead to a timeout or trigger retransmission mechanism. Listen in the web application function of backlog will give us the kernel by default parameters of the net. Core. Somaxconn limit to 128, and defined nginx NGX_LISTEN_BACKLOG defaults to 511, it is necessary to adjust this value. On a busy server, increasing the value is helpful to network performance
OS.net.core.somaxconn.unit                      = The number of
OS.net.core.wmem_default.paramDetail            = The default value of socket sender buffer size
OS.net.core.wmem_default.suggestExplain         = The default send window size
OS.net.core.wmem_default.unit                   = byte
OS.net.core.wmem_max.paramDetail                = The maximum number of sockets sender buffer size
OS.net.core.wmem_max.suggestExplain             = Most TCP data buffer
OS.net.core.wmem_max.unit                       = byte
OS.net.ipv4.ip_local_port_range.paramDetail     = Physical machine available temporary port range
OS.net.ipv4.ip_local_port_range.suggestExplain  = Said to outside connection port range, the default is small, this range will also indirectly used for NAT table size
OS.net.ipv4.ip_local_port_range.unit            = The number of
OS.net.ipv4.tcp_fin_timeout.paramDetail         = The system default timeout
OS.net.ipv4.tcp_fin_timeout.suggestExplain      = Disconnect the socket for this end, the TCP remain in a state of FIN - WAIT - 2 time. The other party may be disconnected or has not been end connections or unpredictable process of death
OS.net.ipv4.tcp_fin_timeout.unit                = seconds
OS.net.ipv4.tcp_keepalive_intvl.paramDetail     = When detecting no confirmation, resend detection frequency
OS.net.ipv4.tcp_keepalive_intvl.suggestExplain  = Detecting messages did not get the response, resend the message time interval (in seconds). The default value is 75 seconds. (for general applications, there are some big, this value can change a little according to need. Especially the web server needs to change small the value, 15 is a more appropriate value)
OS.net.ipv4.tcp_keepalive_intvl.unit            = seconds
OS.net.ipv4.tcp_keepalive_probes.paramDetail    = Before that connection failure, send TCP keepalive probe packets. This value multiplied by tcp_keepalive_intvl determines a connection after sending keepalive can have how much time did not respond
OS.net.ipv4.tcp_keepalive_probes.suggestExplain = TCP keepalive probe messages sent time interval (in seconds), is used to confirm a TCP connection is valid
OS.net.ipv4.tcp_keepalive_probes.unit           = seconds
OS.net.ipv4.tcp_keepalive_time.paramDetail      = Said when the keepalive enabled, the frequency of the TCP keepalive messages sent
OS.net.ipv4.tcp_keepalive_time.suggestExplain   = TCP keepalive probe messages sent time interval (in seconds), is used to confirm a TCP connection is valid. But don't send the data to establish the connection on both sides to prevent attacks
OS.net.ipv4.tcp_keepalive_time.unit             = seconds
OS.net.ipv4.tcp_max_syn_backlog.paramDetail     = Records of those who have not yet received the client confirmation of the maximum number of connection requests
OS.net.ipv4.tcp_max_syn_backlog.suggestExplain  = For those who still have not yet received the client confirmation of connection requests, maximum number needs to be saved in the queue. For more than 128 MB of memory system, the default value is 1024, less than 128 MB of 128. If the server is often appear overload, can try to increase the number. Warning! If you see this value is set to greater than 1024, best to modify the include/net/TCP. H TCP_SYNQ_HSIZE inside, to keep TCP_SYNQ_HSIZE * 16 (SYN Flood attack using TCP protocol distribute defects of shaking hands, a false source IP address sends a large number of the TCP SYN - half to open the connection to the target system, eventually leading to the target system Socket queue resources exhausted and can not accept new connections. To cope with this attack, the more widely used in modern Unix systems connected to buffer queue processing way, not to solve this kind of attack, is to use a basic queue processing normal to Connect fully application (the Connect () and the Accept ()), is to use another queue separately store half open the connection. This double queue processing method and some other system kernel measures (such as Syn - Cookies/Caches) joint application, can more effectively relieve small-scale Syn Flood attack (proved)
OS.net.ipv4.tcp_max_syn_backlog.unit            = The number of
OS.net.ipv4.tcp_max_tw_buckets.paramDetail      = Said while keeping the TIME_WAIT state maximum number of TCP/IP connection. If more than the configured value, TIME_WAIT will be immediately released and print the warning message
OS.net.ipv4.tcp_max_tw_buckets.suggestExplain   = System at the same time the largest processing timewait number of sockets. If more than this number, the time to wait the socket will be immediately axe and display warning information. To set the limit, in order to resist those simple pure DoS attacks, however, if the conditions need to be more than the default value of the network, you can improve it (perhaps even more memory). (in fact do NAT best can appropriately increase the value)
OS.net.ipv4.tcp_max_tw_buckets.unit             = The number of
OS.net.ipv4.tcp_retries1.paramDetail            = In the process of building connection TCP maximum retries
OS.net.ipv4.tcp_retries1.suggestExplain         = Give up to respond to a TCP connection request, need to how much time before retrying. The RFC minimum value is 3
OS.net.ipv4.tcp_retries1.unit                   = The number of
OS.net.ipv4.tcp_retries2.paramDetail            = Control the kernel to have establish a connection to the remote host to send data to the number of times
OS.net.ipv4.tcp_retries2.suggestExplain         = Discarding the activation (communication) has been established in TCP connection, need to how much time before retrying. The default value is 15, according to the RTO value to decide, the equivalent of 13-30 minutes (RFC1122 regulation, must be greater than 100 seconds). (this value according to the current network Settings, can be appropriately changed little, I change to 5) within the network
OS.net.ipv4.tcp_retries2.unit                   = The number of
OS.net.ipv4.tcp_rmem.paramDetail                = TCP protocol at the receiving end of the buffer size of available memory
OS.net.ipv4.tcp_rmem.suggestExplain             = Receive tcp_wmem cache Settings
OS.net.ipv4.tcp_rmem.unit                       = byte
OS.net.ipv4.tcp_sack.paramDetail                = Enable selective response, by selectively response out-of-order packets to improve performance, get to the sender to send only the missing segments (for wide area network) this option should be enabled, but will increase the CPU
OS.net.ipv4.tcp_sack.suggestExplain             = Using Selective ACK, it can be used to find specific lost datagram - so would help to recover quickly. The file said whether to enable Selective response (Selective Acknowledgment), this can be achieved by selectively response out-of-order receives the message to improve performance (this allows the sender to send only the lost packet). (this option should be enabled for wan communication, but it will add to the CPU
OS.net.ipv4.tcp_sack.unit                       = Boolean value
OS.net.ipv4.tcp_syn_retries.paramDetail         = TCP SYN packet retries
OS.net.ipv4.tcp_syn_retries.suggestExplain      = How much for a new connection, the kernel to send a SYN connection request to decide to give up. Should not be greater than 255, the default value is 5, corresponding to the 180 seconds of time.. (for large load and good physical communication network, this value is high, can be changed to 2. This value is only in view of the external connection, the incoming connection, is determined by tcp_retries1)
OS.net.ipv4.tcp_syn_retries.unit                = The number of
OS.net.ipv4.tcp_synack_retries.paramDetail      = TCP SYN response packet maximum retries
OS.net.ipv4.tcp_synack_retries.suggestExplain   = For remote connection requests the SYN, the kernel sends the SYN + ACK datagram, to confirm a SYN connection request packets received. This is called the three-way handshake (threeway handshake) mechanism of the second step. Here decided to sent by the kernel before giving up connection SYN ACK number. Should not be greater than 255, the default value is 5, corresponding to the 180 seconds of time
OS.net.ipv4.tcp_synack_retries.unit             = The number of
OS.net.ipv4.tcp_syncookies.paramDetail          = When there is a SYN waiting queue overflow, enable the cookies, can prevent a small amount of SYN attacks
OS.net.ipv4.tcp_syncookies.suggestExplain       = Only when the kernel compilation occurs when chose CONFIG_SYNCOOKIES role. When there is overflow appeared syn waiting queue syncookies like the other sent. The goal is to prevent the syn flood attack
OS.net.ipv4.tcp_syncookies.unit                 = Boolean value
OS.net.ipv4.tcp_timestamps.paramDetail          = The TCP time stamp (12) will increase in the TCP header, send timeout proportion in a more precise way (see RFC 1323) to enable the RTT calculation, can achieve better performance
OS.net.ipv4.tcp_timestamps.suggestExplain       = Timestamps in other things, can prevent the forgery of sequence number. A 1 g broadband lines may be met with heavy out - of - line numerical old sequence number (if it is due to last time). Timestamp will make it knows this is a 'old packet. Said (the file is enabled in a more accurate than the timeout retransmission method (RFC 1323) to enable the RTT calculation; In order to achieve better performance should enable this option.)
OS.net.ipv4.tcp_timestamps.unit                 = Boolean value
OS.net.ipv4.tcp_tw_recycle.paramDetail          = Said to open a TCP connection in TIME - WAIT state sockets rapid recovery
OS.net.ipv4.tcp_tw_recycle.suggestExplain       = Open the quick TIME - WAIT sockets. Unless technical expert advice or request, please do not modify this value. (do NAT, suggest to open it)
OS.net.ipv4.tcp_tw_recycle.unit                 = Boolean value
OS.net.ipv4.tcp_tw_reuse.paramDetail            = Allow the TIME - WAIT state sockets for a new TCP connection
OS.net.ipv4.tcp_tw_reuse.suggestExplain         = Indicates whether or not allowed to apply in TIME - WAIT state of the socket for the new TCP connection (this to restart some service, quickly and start the prompt after the port is already in use case is helpful)
OS.net.ipv4.tcp_tw_reuse.unit                   = Boolean value
OS.vm.extfrag_threshold.paramDetail             = System memory fails, will the Linux memory fragments score for the current system, if more than the vm extfrag_threshold value, kswapd will trigger the memory compaction. So the value is close to 1000, the system in the processing of memory fragments tend to see the old pages out, for meeting the need of application, and set close to 0, the said system in the processing of memory fragments tend to do the memory compaction
OS.vm.extfrag_threshold.unit                    = score
OS.vm.min_free_kbytes.paramDetail               = Ensure that physical memory has enough free space to prevent sudden change page
OS.vm.min_free_kbytes.unit                      = byte
OS.vm.overcommit_memory.paramDetail             = Control when doing the memory allocation, the kernel checks
OS.vm.overcommit_memory.unit                    = way
OS.vm.overcommit_ratio.paramDetail              = System must not be used too much memory algorithm, the system shall not exceed the memory address space swap RAM the percentage value of this parameter, when the vm. The overcommit_memory = 2 when the parameters take effect
OS.vm.overcommit_ratio.suggestExplain           = The parameter value is only in the vm. Overcommit_memory = 2 cases, this parameter will only take effect

connect.database.tip = Failed to connect to database

exporterinstall.downloadsuccess = \u5B89\u88C5\u5305\u4E0B\u8F7D\u6210\u529F
exporterinstall.pkgexists       = \u5F53\u524D\u8DEF\u5F84\u4E0B\u5DF2\u5B58\u5728\u5B89\u88C5\u5305\uFF0C\u4F7F\u7528\u8BE5\u5B89\u88C5\u5305\u5B89\u88C5
exporterinstall.step1           = \u521D\u59CB\u5316
exporterinstall.step2           = \u68C0\u67E5\u4EE3\u7406\u73AF\u5883
exporterinstall.step3           = \u68C0\u67E5\u7528\u6237\u4FE1\u606F
exporterinstall.step4           = \u5B89\u88C5agent
exporterinstall.step5           = \u542F\u52A8agent
exporterinstall.step6           = \u5237\u65B0prometheus\u914D\u7F6E
exporterinstall.step7           = \u5B89\u88C5\u5B8C\u6210
exporterinstall.uploadsuccess   = \u5B89\u88C5\u5305\u4F20\u8F93\u5B8C\u6210

exporteruninstall.step1 = \u521D\u59CB\u5316
exporteruninstall.step2 = \u8FDE\u63A5\u4E3B\u673A
exporteruninstall.step3 = \u67E5\u627EnodeAgent\u8FDB\u7A0B\u53F7
exporteruninstall.step4 = \u505C\u6B62nodeAgent
exporteruninstall.step5 = \u67E5\u627EopengaussAgent\u8FDB\u7A0B\u53F7
exporteruninstall.step6 = \u505C\u6B62opengaussAgent
exporteruninstall.step7 = \u5378\u8F7D\u5B8C\u6210

install.tryAdd = \u5C1D\u8BD5\u521B\u5EFA{0}\u7528\u6237\u8FDB\u884C\u5B89\u88C5
install.use    = \u4F7F\u7528{0}\u7528\u6237\u8FDB\u884C\u5B89\u88C5

nodeId.tip = node does not exist

password.tip = root password error

prominstall.downloadsuccess = \u5B89\u88C5\u5305\u4E0B\u8F7D\u6210\u529F
prominstall.limit           = \u53EA\u5141\u8BB8\u5B89\u88C51\u4E2APrometheus\u5B9E\u4F8B
prominstall.pkgexists       = \u5F53\u524D\u8DEF\u5F84\u4E0B\u5DF2\u5B58\u5728\u5B89\u88C5\u5305\uFF0C\u4F7F\u7528\u8BE5\u5B89\u88C5\u5305\u5B89\u88C5\u6210\u529F
prominstall.promstartfail   = prometheus \u542F\u52A8\u5931\u8D25
prominstall.step1           = \u5F00\u59CB\u5B89\u88C5
prominstall.step2           = \u68C0\u67E5Prometheus\u5B89\u88C5\u73AF\u5883
prominstall.step3           = \u68C0\u67E5\u7528\u6237\u4FE1\u606F, \u8FDE\u63A5\u4E3B\u673A
prominstall.step4           = \u5B89\u88C5Prometheus
prominstall.step5           = \u542F\u52A8prometheus
prominstall.step6           = \u9A8C\u8BC1prometheus\u542F\u52A8\u72B6\u6001
prominstall.step7           = \u5B89\u88C5\u5B8C\u6210
prominstall.uploadsuccess   = \u5B89\u88C5\u5305\u4F20\u8F93\u6210\u529F

promuninstall.step1 = \u521D\u59CB\u5316
promuninstall.step2 = \u8FDE\u63A5\u4E3B\u673A
promuninstall.step3 = \u67E5\u627Eprometheus\u8FDB\u7A0B\u53F7
promuninstall.step4 = \u505C\u6B62prometheus
promuninstall.step5 = \u5378\u8F7D\u5B8C\u6210
session.detail.general.message=The session id does not exist, probably the session has finished executing and closed.
session.detail.block.message=The number of rows returned by querying block session through sessionid should be equal to 1, but return {0} 
